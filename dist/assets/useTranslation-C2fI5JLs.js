import{r as g,I as _,g as j,R as k,a as G}from"./index-YjUKcW0B.js";const $=(e,n,s,a)=>{var t,f,T,m;const i=[s,{code:n,...a||{}}];if((f=(t=e==null?void 0:e.services)==null?void 0:t.logger)!=null&&f.forward)return e.services.logger.forward(i,"warn","react-i18next::",!0);w(i[0])&&(i[0]=`react-i18next:: ${i[0]}`),(m=(T=e==null?void 0:e.services)==null?void 0:T.logger)!=null&&m.warn?e.services.logger.warn(...i):console!=null&&console.warn&&console.warn(...i)},O={},E=(e,n,s,a)=>{w(s)&&O[s]||(w(s)&&(O[s]=new Date),$(e,n,s,a))},P=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},S=(e,n,s)=>{e.loadNamespaces(n,P(e,s))},A=(e,n,s,a)=>{if(w(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return S(e,s,a);s.forEach(i=>{e.options.ns.indexOf(i)<0&&e.options.ns.push(i)}),e.loadLanguages(n,P(e,a))},U=(e,n,s={})=>!n.languages||!n.languages.length?(E(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0):n.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,i)=>{if(s.bindI18n&&s.bindI18n.indexOf("languageChanging")>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!i(a.isLanguageChangingTo,e))return!1}}),w=e=>typeof e=="string",J=e=>typeof e=="object"&&e!==null,W=(e,n)=>{const s=g.useRef();return g.useEffect(()=>{s.current=e},[e,n]),s.current},F=(e,n,s,a)=>e.getFixedT(n,s,a),X=(e,n,s,a)=>g.useCallback(F(e,n,s,a),[e,n,s,a]),q=(e,n={})=>{var R,v,z,L;const{i18n:s}=n,{i18n:a,defaultNS:i}=g.useContext(_)||{},t=s||a||j();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new k),!t){E(t,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const o=(l,u)=>w(u)?u:J(u)&&w(u.defaultValue)?u.defaultValue:Array.isArray(l)?l[l.length-1]:l,c=[o,{},!1];return c.t=o,c.i18n={},c.ready=!1,c}(R=t.options.react)!=null&&R.wait&&E(t,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const f={...G(),...t.options.react,...n},{useSuspense:T,keyPrefix:m}=f;let r=i||((v=t.options)==null?void 0:v.defaultNS);r=w(r)?[r]:r||["translation"],(L=(z=t.reportNamespaces).addUsedNamespaces)==null||L.call(z,r);const d=(t.isInitialized||t.initializedStoreOnce)&&r.every(o=>U(o,t,f)),M=X(t,n.lng||null,f.nsMode==="fallback"?r:r[0],m),C=()=>M,x=()=>F(t,n.lng||null,f.nsMode==="fallback"?r:r[0],m),[b,y]=g.useState(C);let h=r.join();n.lng&&(h=`${n.lng}${h}`);const I=W(h),N=g.useRef(!0);g.useEffect(()=>{const{bindI18n:o,bindI18nStore:c}=f;N.current=!0,!d&&!T&&(n.lng?A(t,n.lng,r,()=>{N.current&&y(x)}):S(t,r,()=>{N.current&&y(x)})),d&&I&&I!==h&&N.current&&y(x);const l=()=>{N.current&&y(x)};return o&&(t==null||t.on(o,l)),c&&(t==null||t.store.on(c,l)),()=>{N.current=!1,t&&o&&(o==null||o.split(" ").forEach(u=>t.off(u,l))),c&&t&&c.split(" ").forEach(u=>t.store.off(u,l))}},[t,h]),g.useEffect(()=>{N.current&&d&&y(C)},[t,m,d]);const p=[b,t,d];if(p.t=b,p.i18n=t,p.ready=d,d||!d&&!T)return p;throw new Promise(o=>{n.lng?A(t,n.lng,r,()=>o()):S(t,r,()=>o())})};export{q as u};
